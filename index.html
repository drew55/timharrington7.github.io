<!DOCTYPE html>
<html><head><title>Laser Show</title><style>#clock {padding: 10px; border:1px solid #000000; } </style> </head><body><canvas id="clock" width="600" height="600"></canvas>
<script>

Math.TAU = 2 * Math.PI;
const RPS = 10;
const bufSize = 1000;

class LaserSystem {
  constructor(canvas) {
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    const context = canvas.getContext("2d");
    context.lineWidth = 1;
    context.strokeStyle = '#DD0000';
    this.radius = canvas.width / 2;
    this.context = context;
  }
  _paintBeam(progress) {
    const radians = (Math.TAU * progress) - (Math.TAU/4);
    const len = 2* this.radius;
    const targetX = this.centerX + Math.cos(radians) * len;
    const targetY = this.centerY + Math.sin(radians) * len;
    this.context.beginPath();
    this.context.moveTo(this.centerX, this.centerY); // Start at the center
    this.context.lineTo(targetX, targetY); // Draw a line outwards
    this.context.stroke();
  }
  draw(beamBuffer, onOffBuffer) {
    this.context.clearRect(0,0,600,600);
    const usNow = window.performance.now() * 1000;   
    const usStart = usNow - (10 * 1000);
    const usEnd = usNow - (5 * 1000);
    const cursor = new OnOffCursor(onOffBuffer, usStart)
    beamBuffer.playBeams(usStart, usEnd, (x, usTime) => {
      if (cursor.isOn(usTime)) {
        this._paintBeam(x);
      }
    });
  }
}

class BeamAngleBuffer {
  constructor(bufSize, usStepSize, usStartTime, usPerRevolution) {
    this.usPerRevolution = usPerRevolution;
    this.bufSize = bufSize;
    this.usStartTime = usStartTime;
    this.angles = [];
    this.times = [];
    for (let i = 0; i < bufSize; i++) {
      this.angles[i] = -1;
      this.times[i] = null;
    }
    this.curIndex = 0;
    this.usStepSize = usStepSize;
  }
  playBeams(usStart, usEnd, cb) {
    let endIndex = this.curIndex;
    let index = this.curIndex;
    do {
      index--;
    } while (this.times[index % this.bufSize] > usStart)
    index++;
    do {
      const t = this.times[index];
      const angle = this.angles[index % this.bufSize];
      if (angle > -1) {
        cb(angle, t);
      }
      index++;
    } while (index < endIndex && this.times[index % this.bufSize] < usEnd);
  }
  // Compute all the beam angles for a sequence of increments 
  // between last time and now
  update(usNow) {
    if (this.curIndex === 0) {
      const usDelta = (usNow - this.usStartTime) % this.usPerRevolution;
      this.angles[this.curIndex % this.bufSize] = usDelta / this.usPerRevolution;
      this.times[this.curIndex % this.bufSize] = usNow;
      this.curIndex++;
    } else {
      const usPrev = this.times[(this.curIndex - 1) % this.bufSize];
      let usStep = usPrev + this.usStepSize;
      do {
        const usStepSize = getRandomInt(this.usStepSize - 2, this.usStepSize + 2);
        const usDelta = (usStep - this.usStartTime) % this.usPerRevolution;
        this.angles[this.curIndex % this.bufSize] = usDelta / this.usPerRevolution;
        this.times[this.curIndex % this.bufSize] = usStep;
        usStep += usStepSize;
        this.curIndex++;
        if (this.curIndex === 2 * this.bufSize) {
          this.curIndex = this.bufSize;
        }
      } while (usStep <= usNow)
    }
  }
}

class OnOffCursor {
  constructor(onOffBuffer, usStart) {
    this.buf = onOffBuffer;
    this.cursor = onOffBuffer.curIndex;
    this.seek(usStart);
  }
  seek(usStep) {
    if (this.buf.times[this.cursor % this.buf.bufSize] > usStep) {
      while (this.buf.times[this.cursor % this.buf.bufSize] > usStep) {
        if (this.buf.times[(this.cursor - 1) % this.buf.bufSize]) {
          this.cursor--;
        } else {
          break;
        }
      }
    } else if (this.buf.times[this.cursor % this.buf.bufSize] === usStep) {
      // hit
    } else if (this.buf.times[this.cursor % this.buf.bufSize] < usStep) {
      while (this.buf.times[this.cursor % this.buf.bufSize] < usStep) {
        if (this.cursor === this.buf.curIndex) {
          break;
        }
        if (this.buf.times[this.cursor % this.buf.bufSize]) {
          this.cursor++;
        } else {
          break;
        }
      }
      if (this.buf.times[(this.cursor - 1) % this.buf.bufSize]) {
        this.cursor--;
      }
    }
  }
  isOn(usBeamTime) {
    this.seek(usBeamTime);
    return this.buf.isOn[this.cursor % this.buf.bufSize];
  }
}

class OnOffBuffer {
  constructor(bufSize, usStartTime, usPerRevolution) {
    this.usPerRevolution = usPerRevolution;
    this.bufSize = bufSize;
    this.usStartTime = usStartTime;
    this.isOn = [];
    this.times = [];
    for (let i = 0; i < bufSize; i++) {
      this.isOn[i] = false;
      this.times[i] = null;
    }
    this.curIndex = 0;
    this.usStepSize = 7;
  }
  _isOn(position) {
    if (position > .25 && position < .75) {
      return true;
    } else {
      return false;
    }
  }
  // Compute the on/off status for a sequence of increments between last time
  // and now
  update(usNow) {
    if (this.curIndex === 0) {
      const usDelta = (usNow - this.usStartTime) % this.usPerRevolution;
      this.isOn[this.curIndex] = this._isOn(usDelta / this.usPerRevolution);
      this.times[this.curIndex] = usNow;
      this.curIndex++;
    } else {
      const usPrev = this.times[(this.curIndex - 1) % this.bufSize];
      let usStep = usPrev + this.usStepSize;
      do {
        const usDelta = (usStep - this.usStartTime) % this.usPerRevolution;
        this.isOn[this.curIndex % this.bufSize] = this._isOn(usDelta / this.usPerRevolution);
        this.times[this.curIndex % this.bufSize] = usStep;
        usStep += this.usStepSize;
        this.curIndex++;
        if (this.curIndex === 2 * this.bufSize) {
          this.curIndex = this.bufSize;
        }
      } while (usStep <= usNow)
    }
  }
}

//class GenericBuffer


function start() {
  const canvas1 = document.querySelector("#clock");
  const usPerRevolution = (1000 * 1000) / RPS;

  let updateInterval = null;
  let drawInterval = null;
  let isStarted = false;
  const laserSystem = new LaserSystem(canvas1);

  function toggle() {
    if (isStarted) {
      clearInterval(updateInterval);
      clearInterval(drawInterval);
      updateInterval = null;
      drawInterval = null;
      isStarted = false;
    } else {
      isStarted = true;
      const usStartTime = window.performance.now() * 1000;
      const beamBuffer = new BeamAngleBuffer(bufSize, usStartTime, usPerRevolution);
      const onOffBuffer = new OnOffBuffer(bufSize, usStartTime, usPerRevolution);
      updateInterval = setInterval(function() {
        const usNow =  window.performance.now() * 1000;
        onOffBuffer.update(usNow);
        beamBuffer.update(usNow);
      }, 5);
      drawInterval = setInterval(function() {
        laserSystem.draw(beamBuffer, onOffBuffer);
      }, 20);
    }
  }
  canvas1.addEventListener('click', toggle, false);
  toggle();
}

// min inclusive, max exclusive
function getRandomInt(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
}

document.addEventListener('DOMContentLoaded', start);

</script></body></html>
