<!DOCTYPE html>
<html><head><title>Laser Show</title><style>#clock {padding: 10px; border:1px solid #000000; } </style> </head><body>
<h1>Laser tower simulator</h1>
<p>Click the canvas to pause the simulation</p>
<canvas id="clock" width="600" height="600"></canvas>

<script>
Math.TAU = 2 * Math.PI;
const RPS = 100;
const size = 3000;
const usPerRevolution = (1000 * 1000) / RPS;

class LaserSystem {
  constructor(canvas, usRenderDelay, usRenderWindow) {
    this.centerX = canvas.width / 2;
    this.centerY = canvas.height / 2;
    const context = canvas.getContext("2d");
    context.lineWidth = 2;
    context.strokeStyle = '#DD0000';
    this.radius = canvas.width / 2;
    this.context = context;
    this.usRenderWindow = usRenderWindow;
    this.usRenderDelay = usRenderDelay;
  }
  _paintBeam(progress) {
    const radians = (Math.TAU * progress) - (Math.TAU/4);
    const len = 2* this.radius;
    const targetX = this.centerX + Math.cos(radians) * len;
    const targetY = this.centerY + Math.sin(radians) * len;
    this.context.beginPath();
    this.context.moveTo(this.centerX, this.centerY); // Start at the center
    this.context.lineTo(targetX, targetY); // Draw a line outwards
    this.context.stroke();
  }
  draw(beamBuffer, showBuffer) {
    this.context.clearRect(0,0,600,600);
    const usNow = window.performance.now() * 1000;   
    const usEnd = usNow - this.usRenderDelay;
    const usStart = usNow - this.usRenderDelay - this.usRenderWindow;
    const cursor = new BeamBufferCursor(showBuffer, usStart)
    beamBuffer.playBeams(usStart, usEnd, (position, usTime) => {
      if (cursor.isOn(usTime, position)) {
        this._paintBeam(position);
      }
    });
  }
}

class BeamBuffer {
  constructor(bufferSize, usStepSize, usStartTime, usPerRevolution) {
    this.usPerRevolution = usPerRevolution;
    this.size = bufferSize;
    this.usStartTime = usStartTime;
    this.values = [];
    this.times = [];
    for (let i = 0; i < size; i++) {
      this.values[i] = false;
      this.times[i] = null;
    }
    this.curIndex = 0;
    this.usStepSize = usStepSize;
  }  
  update(usNow) {
    if (this.curIndex === 0) {
      const usDelta = (usNow - this.usStartTime) % this.usPerRevolution;
      this.values[this.curIndex] = this.computeValue(usDelta / this.usPerRevolution, usNow);
      this.times[this.curIndex] = usNow;
      this.curIndex++;
    } else {
      const usPrev = this.times[(this.curIndex - 1) % this.size];
      let usStep = usPrev + this.usStepSize;
      do {
        const usDelta = (usStep - this.usStartTime) % this.usPerRevolution;
        this.values[this.curIndex % this.size] = this.computeValue(usDelta / this.usPerRevolution, usStep);
        this.times[this.curIndex % this.size] = usStep;
        usStep += this.usStepSize;
        this.curIndex++;
        if (this.curIndex === 2 * this.size) {
          this.curIndex = this.size;
        }
      } while (usStep <= usNow)
    }
  }
  computeValue(position, usTime) {
    throw new Error('not implemented in base class');
  }
}

// Compute the beam progress around the circle (expressed as a value between 0
// and 1) every few microseconds
class BeamAngleBuffer extends BeamBuffer {
  playBeams(usStart, usEnd, cb) {
    let endIndex = this.curIndex;
    let index = this.curIndex;
    // Find the first beam with time > usStart
    do {
      index--;
    } while (this.times[index % this.size] > usStart)
    index++;
    // Play the beams until the buffer runs out or a
    // beam with time > usEnd is reached
    do {
      const angle = this.values[index % this.size];
      if (angle > -1) {
        cb(angle, this.times[index % this.size]);
      }
      index++;
    } while (index < endIndex && this.times[index % this.size] < usEnd);
  }
  computeValue(position, usTime) {
    return position;
  }
}

class BeamBufferCursor {
  constructor(showBuffer, usStart) {
    this.buffer = showBuffer;
    this.cursor = showBuffer.curIndex;
    this.seek(usStart);
  }
  decrement() {
    if ((this.buffer.curIndex % this.buffer.size) === ((this.cursor - 1) % this.buffer.size)) {
      return false;
    }
    this.cursor--;
  }
  increment() {
    if ((this.buffer.curIndex % this.buffer.size) === ((this.cursor + 1) % this.buffer.size)) {
      return false;
    }
    this.cursor++;
  }
  seek(usStep) {
    if (this.buffer.times[this.cursor % this.buffer.size] > usStep) {
      //console.log('case 1');
      while (this.buffer.times[this.cursor % this.buffer.size] >= usStep) {
        if (!this.decrement()) {
          break;
        }
      }
    } else if (this.buffer.times[this.cursor % this.buffer.size] === usStep) {
      //console.log('case 2');
      while (this.buffer.times[this.cursor % this.buffer.size] === usStep) {
        if (!this.decrement()) {
          break;
        }
      }
    } else if (this.buffer.times[this.cursor % this.buffer.size] < usStep) {
      //console.log('case 3');
      while (this.buffer.times[this.cursor % this.buffer.size] <= usStep) {
        if (!this.increment()) {
          break;
        }
      }
      this.seek(usStep);
    }
  }
  isOn(usBeamTime, position) {
    this.seek(usBeamTime);
    const bufferTime = this.buffer.times[this.cursor % this.buffer.size];
    if (bufferTime >= usBeamTime && this.buffer.times[(this.cursor - 1) % this.buffer.size]) {
      throw new Error('wtf1');
    }
    const isOn = this.buffer.values[this.cursor % this.buffer.size];
    return isOn;
  }
}

class ShowEffect {
  setup(startPosition, usStartTime) {
    this.startPosition = startPosition;
    this.usStartTime = usStartTime;
  }
  isLaserOn(position, timeUs) {
    return true;
  }
  isFinished() {
    return false;
  }
}

class HalfDiskEffect extends ShowEffect {
  isLaserOn(position, time) {
    if (position < .25 || position > .75) {
      return true;
    } else {
      return false;
    }
  }  
}

class SunRayEffect extends ShowEffect {
  constructor(beamCount = 7, usRotationTime = 0) {
    super();
    this.beamCount = beamCount;
    this.bucketWidth = 1 / beamCount;
    this.usRotationTime = usRotationTime;
  }
  isLaserOn(position, usTime) {
    let positionRotationOffset = 0;
    if (this.usRotationTime) {
      const delta = (usTime - this.usStartTime) % this.usRotationTime;
      positionRotationOffset = delta / this.usRotationTime;
    }
    position = (position + positionRotationOffset) % 1;
    position = (position / this.bucketWidth) % 1;
    if (position < .5) {
      return true;
    } else {
      return false;
    }
  }  
}

class LaserShowBuffer extends BeamBuffer {
  constructor(bufferSize, usStepSize, usStartTime, usPerRevolution) {
    super(bufferSize, usStepSize, usStartTime, usPerRevolution);
    this.effects = [];
    this.currentEffectPos = -1;
  }
  addEffect(showEffect) {
    this.effects = [showEffect]
  }
  getNextEffect() {
    this.currentEffectPos++;
    return this.effects[0];
  }
  computeValue(position, time) {
    if (!this.effect || this.effect.isFinished()) {
      this.effect = this.getNextEffect();
      this.effect.setup(position, time);
    }
    return this.effect.isLaserOn(position, time);
  }
}

function start() {
  const canvas1 = document.querySelector("#clock");
  let updateInterval = null;
  let drawInterval = null;
  let isStarted = false;
  const usRenderDelay = 30 * 1000;
  const usRenderWindow = 10 * 1000;
  const laserSystem = new LaserSystem(canvas1, usRenderDelay, usRenderWindow);
  const usStartTime = window.performance.now() * 1000;
  const beamBuffer = new BeamAngleBuffer(size, 17, usStartTime, usPerRevolution);
  const showBuffer = new LaserShowBuffer(size, 23, usStartTime, usPerRevolution);
  showBuffer.addEffect(new SunRayEffect(7, 5 * 1000 * 1000));
  function toggle() {
    if (isStarted) {
      clearInterval(updateInterval);
      clearInterval(drawInterval);
      updateInterval = null;
      drawInterval = null;
      isStarted = false;
    } else {
      isStarted = true;
      updateInterval = setInterval(function() {
        const usNow =  window.performance.now() * 1000;
        showBuffer.update(usNow);
        beamBuffer.update(usNow);
      }, 5);
      drawInterval = setInterval(function() {
        laserSystem.draw(beamBuffer, showBuffer);
      }, 5);
    }
  }
  canvas1.addEventListener('click', toggle, false);
  toggle();
}

document.addEventListener('DOMContentLoaded', start);
</script>

<h3>How it works</h3>
<p>One function continuously computes a buffer of beam positions and times at the
microsecond resolution given how fast the beam is spinning. A second function
continuously computes the laser on/off status at the microsecond resolution. A
third function continuously renders the last 10ms worth of beams, considering
whether the laser is on or off at the time the beam is to be shown. Being off
suppresses the beam from rendering. The simulated laser is spinning at 100
revolutions per second (RPS).

The first function simulates the physical laser and the mirror spinning at 100
RPS. The second function simulates the arduino sending a TTL signal to the
laser (in the form of a "turn the beam off" command).
</p>
</body></html>
